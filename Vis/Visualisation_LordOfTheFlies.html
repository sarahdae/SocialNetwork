<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8'>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Visualisation Lord of the Flies</title>
        <link rel="stylesheet" type="text/css" href="networks.css"/>
        <link rel="stylesheet" href="//code.jquery.com/ui/1.12.0/themes/base/jquery-ui.css">
        <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
        <script src="https://code.jquery.com/ui/1.12.0/jquery-ui.js"></script>

    </head>
    <body>
        <!--Button to go back to the main page-->
        <button class="standard-button" onclick="window.location.href = './welcome.html'">Back</button><br><br>
        <script src='http://d3js.org/d3.v3.min.js'></script>
        <script type="text/javascript" src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>

        <script>


//Dimensions of the visualization
            var width = 740,
                    height = 580;
            var color = d3.scale.category20();
            //create a SVG container which holds the visualization
            //and specifiy the dimensions for this oontainer
            var svg = d3.select('body').append('svg')
                    .attr('width', width)
                    .attr('height', height)

            //Set up tooltip
            var tip = d3.tip()
                    .attr('class', 'd3-tip')
                    .offset([-10, 0])
                    .html(function (d) {
                        return  d.name + "</span>";
                    })
            svg.call(tip);



            d3.json("countOcc.json", function (error, graph) {
                if (error)
                        throw error;
                    //Create a force layout object
                    //Set the size of the object to the predefined size 
                    //and define the linkDistance between the nodes
                    var force = d3.layout.force()
                            .size([width, height])
                            .nodes(graph.nodes)
                            .links(graph.links)
                            .linkDistance(function (d) {



                                if (d.length === 1000) {
                                    return Math.sqrt(d.length) * 12.5;
                                } else if (d.length === 2000) {
                                    return Math.sqrt(d.length) * 6;
                                } else if (d.length === 3000) {
                                    return Math.sqrt(d.length) * 3.8;
                                } else if (d.length === 4000) {
                                    return Math.sqrt(d.length) * 2.7;
                                } else if (d.length === 5000) {
                                    return Math.sqrt(d.length) * 2;
                                } else if (d.length >= 6000) {
                                    return Math.sqrt(d.length) * 1.5;
                                } else if (d.length >= 8000) {
                                    return Math.sqrt(d.length);
                                } else if (d.length === 10000) {
                                    return Math.sqrt(d.length) / 1.25;
                                } else if (d.length >= 11000) {
                                    return Math.sqrt(d.length) / 1.5;
                                } else if (d.length === 13000) {
                                    return Math.sqrt(d.length) / 2;
                                } else if (d.length >= 14000) {
                                    return Math.sqrt(d.length) / 2.5;
                                } else if (d.length === 16000) {
                                    return Math.sqrt(d.length) / 3;
                                } else if (d.length === 17000) {
                                    return Math.sqrt(d.length) / 4;
                                } else if (d.length === 18000) {
                                    return Math.sqrt(d.length) / 4.5;
                                } else if (d.length === 19000) {
                                    return Math.sqrt(d.length) / 5;
                                } else if (d.length === 20000) {
                                    return Math.sqrt(d.length) / 6;
                                } else if (d.length === 21000) {
                                    return Math.sqrt(d.length) / 8;
                                } else if (d.length === 22000) {
                                    return Math.sqrt(d.length) / 11;
                                } else if (d.length === 23000) {
                                    return Math.sqrt(d.length) / 15;
                                } else if (d.length === 24000) {
                                    return Math.sqrt(d.length) / 24;
                                } else if (d.length === 25000) {
                                    return Math.sqrt(d.length) / 50;
                                } else {
                                    return Math.sqrt(d.length);
                                }
                            })
                            .start();
                // return Math.sqrt(d.length) * 2;

                //add links to the visualization
                var link = svg.selectAll('.link')
                        .data(graph.links)
                        .enter().append('line')
                        .attr('class', 'link')
                        .style("stroke-width", function (d) {
                            return Math.sqrt(d.value);
                        });
                //add nodes to the visualization
                var node = svg.selectAll('.node')
                        .data(graph.nodes)
                        .enter().append('circle')
                        .attr('class', 'node')
                        .attr("r", function (d) {
                            return Math.sqrt(d.size) / 7 || 4.5;
                        })
                        .style("fill", function (d) {
                            return color(d.group);
                        })
                        .call(force.drag)
                        .on('mouseover', tip.show) //Added
                        .on('mouseout', tip.hide) //Added
                        .on('click', connectedNodes);
                force.on("tick", function () {
                    link.attr("x1", function (d) {
                        return d.source.x;
                    })
                            .attr("y1", function (d) {
                                return d.source.y;
                            })
                            .attr("x2", function (d) {
                                return d.target.x;
                            })
                            .attr("y2", function (d) {
                                return d.target.y;
                            });
                    node.attr("cx", function (d) {
                        return d.x;
                    })
                            .attr("cy", function (d) {
                                return d.y;
                            });
                });
                //Toggle stores whether the highlighting is on
                var toggle = 0;
                //Create an array logging what is connected to what
                var linkedByIndex = {};
                for (i = 0; i < graph.nodes.length; i++) {
                    linkedByIndex[i + "," + i] = 1;
                }
                ;
                graph.links.forEach(function (d) {
                    linkedByIndex[d.source.index + "," + d.target.index] = 1;
                });
                //This function looks up whether a pair are neighbours
                function neighboring(a, b) {
                    return linkedByIndex[a.index + "," + b.index];
                }

                //Reduce opacity of all but the neighbouring nodes
                function connectedNodes() {
                    if (toggle === 0) {
                        d = d3.select(this).node().__data__;
                        node.style("opacity", function (o) {
                            return neighboring(d, o) | neighboring(o, d) ? 1 : 0.1;
                        });
                        link.style("opacity", function (o) {
                            return d.index === o.source.index | d.index === o.target.index ? 1 : 0.1;
                        });
                        //Reduce the op
                        toggle = 1;
                    } else {
                        //Put them back to opacity=1
                        node.style("opacity", 1);
                        link.style("opacity", 1);
                        toggle = 0;
                    }
                }

                //Show all nodes without reduced opacity (only needed by mouseover)
                /*   function allNodes() {
                 if (toggle !== 0) {
                 //Put them back to opacity=1
                 node.style("opacity", 1);
                 link.style("opacity", 1);
                 toggle = 0;
                 }
                 toggle = 0;
                 }*/
            });


<!-- Vertical slider -->
<!-- applet id can be used to get a reference to the applet object -->
            //          var attributes = {id: 'NetworksApplet',
            //                code: 'NetworksApplet', width: 1, height: 1};
            //    var parameters = {jnlp_href: 'NetworksApplet.jnlp'};
            //    deployJava.runApplet(attributes, parameters, '1.6');

            //Slider
            var selection;
            var chap;
            $(function () {
                $("#slider-horizontal").slider({
                    orientation: "horizontal",
                    range: "min",
                    min: 0,
                    max: 34,
                    value: 1,
                    slide: function (event, ui) {
                        $("#amount").val(ui.value);
                    }
                });
                $("#amount").val($("#slider-horizontal").slider("value"));
                selection = ($("#slider-horizontal").slider("value"));
                console.log(selection);

                if (selection === 1) {
                    chap = "1";
                    NetworksApplet.chapter = 1;
                } else if (selection === 2) {
                    chap = "2";
                    NetworksApplet.chapter = 2;
                } else if (selection === 3) {
                    chap = "3";
                    NetworksApplet.chapter = 3;
                } else if (selection === 4) {
                    chap = "4";
                    NetworksApplet.chapter = 4;
                } else if (selection === 5) {
                    chap = "5";
                    NetworksApplet.chapter = 5;
                } else if (selection === 6) {
                    chap = "6";
                    NetworksApplet.chapter = 6;
                } else if (selection === 7) {
                    chap = "7";
                    NetworksApplet.chapter = 7;
                } else {
                    chap = "else";
                }
                console.log(chap);

            });

            //System.out.print(chap);


        </script>

    <applet code="NewJApplet" name="testApplet" width="300" height="100"></applet>
    <button onclick="document.NewJApplet.main()">Test</button>

    <!-- Label of the slider -->
    <p>
        <label for="amount">Chapter:</label>
        <input type="text" id="amount" readonly style="border:0; color:#f6931f; font-weight:bold; width: 25px; text-align: center;">
    </p>
    <div id="slider-horizontal" style="height:10px;"></div>
    <p>

    </p>


    <!--Depending on the chosen value on the slider, another json file is used
    or only one file which is filtered after the chapter No.??-->


</body>
</html>
